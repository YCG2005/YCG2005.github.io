<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>勤学馆</title>
    <link>http://ycg0508.com/</link>
    
    <atom:link href="http://ycg0508.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>黑发不知勤学早，白首方悔读书迟 -- 颜真卿</description>
    <pubDate>Fri, 17 Nov 2023 14:13:43 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title></title>
      <link>http://ycg0508.com/2023/11/17/%E4%BF%A1%E5%8F%B7%E8%A1%A8/</link>
      <guid>http://ycg0508.com/2023/11/17/%E4%BF%A1%E5%8F%B7%E8%A1%A8/</guid>
      <pubDate>Fri, 17 Nov 2023 11:45:16 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;信号表&quot;&gt;&lt;a href=&quot;#信号表&quot; class=&quot;headerlink&quot; title=&quot;信号表&quot;&gt;&lt;/a&gt;信号表&lt;/h1&gt;&lt;p&gt;![image-20231117194508191](C:&#92;Users&#92;Yan chang guo&#92;AppData&#92;Roaming&#92;</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="信号表"><a href="#信号表" class="headerlink" title="信号表"></a>信号表</h1><p>![image-20231117194508191](C:\Users\Yan chang guo\AppData\Roaming\Typora\typora-user-images\image-20231117194508191.png)</p><p>![image-20231117194443533](C:\Users\Yan chang guo\AppData\Roaming\Typora\typora-user-images\image-20231117194443533.png)</p><h2 id="SIGCHLD-–在子进程终止时系统会向该子进程的父进程发送SIGCHLD信号，子进程在接收到SIGSTOP-挂起-信号和SIGCONT-唤醒-信号时都会触发SIGCHLD信号。"><a href="#SIGCHLD-–在子进程终止时系统会向该子进程的父进程发送SIGCHLD信号，子进程在接收到SIGSTOP-挂起-信号和SIGCONT-唤醒-信号时都会触发SIGCHLD信号。" class="headerlink" title="SIGCHLD –在子进程终止时系统会向该子进程的父进程发送SIGCHLD信号，子进程在接收到SIGSTOP(挂起)信号和SIGCONT(唤醒)信号时都会触发SIGCHLD信号。"></a>SIGCHLD –在子进程终止时系统会向该子进程的父进程发送SIGCHLD信号，子进程在接收到SIGSTOP(挂起)信号和SIGCONT(唤醒)信号时都会触发SIGCHLD信号。</h2>]]></content:encoded>
      
      
      
      
      <comments>http://ycg0508.com/2023/11/17/%E4%BF%A1%E5%8F%B7%E8%A1%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title></title>
      <link>http://ycg0508.com/2023/11/14/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6/</link>
      <guid>http://ycg0508.com/2023/11/14/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6/</guid>
      <pubDate>Tue, 14 Nov 2023 05:52:50 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;title:多进程的调度&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;多进程的调度&quot;&gt;&lt;a href=&quot;#多进程的调度&quot; class=&quot;headerlink&quot; title=&quot;多进程的调度&quot;&gt;&lt;/a&gt;多进程的调度&lt;/h1&gt;&lt;h2 id=&quot;进程的系统调用&quot;&gt;&lt;a href=&quot;#进程的系统</description>
        
      
      
      
      <content:encoded><![CDATA[<p>title:多进程的调度</p><hr><h1 id="多进程的调度"><a href="#多进程的调度" class="headerlink" title="多进程的调度"></a>多进程的调度</h1><h2 id="进程的系统调用"><a href="#进程的系统调用" class="headerlink" title="进程的系统调用"></a>进程的系统调用</h2><blockquote><p>Linux下创建新进程的系统调用是fork</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* fork */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">fork</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">父进程中返回的是子进程的pid，子进程中则返回0，fork调用失败返回 -1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h2><blockquote><p>发生僵尸进程的情况是父进程在退出时子进程还没有退出，导致内核中子进程所属的资源没有被正确回收所造成的资源浪费。</p><p><strong>发生僵尸进程一般有两种情况：</strong></p><p>1.在子进程结束运行之后，父进程读取其退出状态之前，我们称该子进程处于僵尸态。</p><p>2.另外一种使子进程进入僵尸态的情况是：父进程结束或者异常终止，而子进程继续运行。此时子进程的PPID将被操作系统设置为1，即init进程。init进程接管了该子进程，并等待它结束。在父进程退出之后，子进程退出之前，该子进程处于僵尸态。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 线程等待函数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">wait</span><span class="params">(<span class="type">int</span> * stat_loc)</span></span>;</span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="type">int</span> * stat_loc, <span class="type">int</span> options)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数解释：</span></span><br><span class="line"><span class="comment">stat_loc -- 存储子进程的退出状态信息</span></span><br><span class="line"><span class="comment">options -- 控制waitpid行为，一般取值为WNOHANG表示非阻塞</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><blockquote><p>wait 和 waitpid 不同点在于wait是全局等待回收进程，并且是阻塞的。</p><p>waitpid则可以指定等待回收进程，并且是非阻塞的，不过一般在使用非阻塞特性的时候，都会保证目标进程实际退出了。</p></blockquote><h2 id="System-V-IPC"><a href="#System-V-IPC" class="headerlink" title="System V IPC"></a>System V IPC</h2><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><h4 id="semget系统调用"><a href="#semget系统调用" class="headerlink" title="semget系统调用"></a>semget系统调用</h4><blockquote><p>用于创建一个新的信号量级，或者获取一个以及存在的信号量级</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* semget */</span></span><br><span class="line"><span class="comment">/* 成功返回信号量标识符，失败返回 -1，设置errno */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">semget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> num_sems, <span class="type">int</span> sem_flags)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数解释：</span></span><br><span class="line"><span class="comment">key -- key表示一个键值，用来标识一个全局唯一的信号量集</span></span><br><span class="line"><span class="comment">num_sems -- 指定要创建/获取的信号量集中的信号量的数目，如果</span></span><br><span class="line"><span class="comment">是创建信号量，则该值必须被指定；如果是获取已经存在的信号量，</span></span><br><span class="line"><span class="comment">则可以把它设置为0。</span></span><br><span class="line"><span class="comment">sem_flags -- 指定一组标志,设置信号量的权限</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="semop函数"><a href="#semop函数" class="headerlink" title="semop函数"></a>semop函数</h4><blockquote><p>semop调用改变信号量的值</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* semop定义 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">semop</span><span class="params">(<span class="type">int</span> sem_id, <span class="keyword">struct</span> sembuf* sem_ops, <span class="type">size_t</span> num_sem_ops)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数解释：</span></span><br><span class="line"><span class="comment">sem_id -- 目标信号量集</span></span><br><span class="line"><span class="comment">sem_ops -- 指向一个sembuf的结构体</span></span><br><span class="line"><span class="comment">num_sem_ops -- 指定要执行的操作个数，sem_ops数组中元素的个数</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* sembuf结构体 */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sembuf</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> sem_num;<span class="comment">/* 信号量编号 */</span>  </span><br><span class="line">  <span class="type">short</span> <span class="type">int</span> sem_op;<span class="comment">/* 指定操作类型 */</span></span><br><span class="line">  <span class="type">short</span> <span class="type">int</span> sem_flg;<span class="comment">/* 影响sem_op成员的变量 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="senctl函数"><a href="#senctl函数" class="headerlink" title="senctl函数"></a>senctl函数</h4><blockquote><p>semctl函数允许调用者对信号量进行直接的控制</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">semctl</span><span class="params">(<span class="type">int</span> sem_id, sem_num, <span class="type">int</span> command,...)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数解释：</span></span><br><span class="line"><span class="comment">sem_id -- 信号量集合标识符</span></span><br><span class="line"><span class="comment">sem_num -- 被操作的信号量在信号量集合中的编号</span></span><br><span class="line"><span class="comment">command -- 指定要执行的命令</span></span><br><span class="line"><span class="comment">... -- 接收可变参，参数类型可自定义</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 推荐的参数类型格式 */</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">semun</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> val;<span class="comment">/*用于SETVAL命令*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">semid_ds</span>*buf;<span class="comment">/*用于IPC_STAT和IPC_SET命令*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span>*array;<span class="comment">/*用于GETALL和SETALL命令*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">seminfo</span>*__buf;<span class="comment">/*用于IPC_INFO命令*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">seminfo</span></span><br><span class="line">&#123;</span><br><span class="line">内核没有使</span><br><span class="line"><span class="type">int</span> semmap;<span class="comment">/*Linux内核没有使用*/</span></span><br><span class="line"><span class="type">int</span> semmni;<span class="comment">/*系统最多可以拥有的信号量集数目*/</span></span><br><span class="line"><span class="type">int</span> semmns;<span class="comment">/*系统最多可以拥有的信号量数目*/</span></span><br><span class="line"><span class="type">int</span> semmnu;<span class="comment">/*Linux内核没有使用*/</span></span><br><span class="line"><span class="type">int</span> semmsl;<span class="comment">/*一个信号量集最多允许包含的信号量数目*/</span></span><br><span class="line"><span class="type">int</span> semopm;<span class="comment">/*semop一次最多能执行的sem_op操作数目*/</span></span><br><span class="line"><span class="type">int</span> semume;<span class="comment">/*Linux内核没有使用*/</span></span><br><span class="line"><span class="type">int</span> semusz;<span class="comment">/*sem_undo结构体的大小*/</span></span><br><span class="line"><span class="type">int</span> semvmx;<span class="comment">/*最大允许的信号量值*/</span></span><br><span class="line"><span class="comment">/*最多允许的UNDO次数（带SEM_UNDO标志的semop操作的次数）*/</span></span><br><span class="line"><span class="type">int</span> semaem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>针对 semA_id 和 sem_num 变量，</p><p>GETNCNT、GETPID、GETVAL、GETZCNT和SETVAL操作的是单个信号量它是由标识符sem_id指定的信号量集中的第sem_num个信号量；而其他操作针对的是整个信号量集，此时semctl的参数sem_num被忽略。</p></blockquote><h3 id="特殊键值IPC-PRIVATE"><a href="#特殊键值IPC-PRIVATE" class="headerlink" title="特殊键值IPC_PRIVATE"></a>特殊键值IPC_PRIVATE</h3><blockquote><p>IPC_PRIVATE（实值为0）可以用于semget函数的key值，IPC_PRIVATE键值用于标识共享信号量，一般用于在多进程环境下同步各子进程对I&#x2F;O复用的调用权。</p></blockquote><h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><h3 id="shmget函数"><a href="#shmget函数" class="headerlink" title="shmget函数"></a>shmget函数</h3><blockquote><p>shmget创建一段新的共享内存</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* shmget函数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数解释：</span></span><br><span class="line"><span class="comment">key -- key参数是一个键值，用来标识一段全局唯一的共享内存</span></span><br><span class="line"><span class="comment">size -- 共享内存的大小</span></span><br><span class="line"><span class="comment">shmflg -- 设置共享内存的权限</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><blockquote><p>使用shmget创建共享内存时将同时初始化 shmid_ds 内核数据结构</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">shmid_ds</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ipc_perm</span> shm_perm;<span class="comment">/*共享内存的操作权限*/</span></span><br><span class="line"><span class="type">size_t</span> shm_segsz;<span class="comment">/*共享内存大小，单位是字节*/</span></span><br><span class="line"><span class="type">__time_t</span> shm_atime;<span class="comment">/*对这段内存最后一次调用shmat的时间*/</span></span><br><span class="line"><span class="type">__time_t</span> shm_dtime;<span class="comment">/*对这段内存最后一次调用shmdt的时间*/</span></span><br><span class="line"><span class="type">__time_t</span> shm_ctime;<span class="comment">/*对这段内存最后一次调用shmctl的时间*/</span></span><br><span class="line"><span class="type">__pid_t</span> shm_cpid;<span class="comment">/*创建者的PID*/</span></span><br><span class="line"><span class="type">__pid_t</span> shm_lpid;<span class="comment">/*最后一次执行shmat或shmdt操作的进程的PID*/</span></span><br><span class="line"><span class="type">shmatt_t</span> shm_nattach;<span class="comment">/*目前关联到此共享内存的进程数量*/</span></span><br><span class="line"><span class="comment">/*省略一些填充字段*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="shmat-shmdt函数"><a href="#shmat-shmdt函数" class="headerlink" title="shmat&#x2F;shmdt函数"></a>shmat&#x2F;shmdt函数</h3><blockquote><p>shmat将共享内存关联到进程的地址空间，shmat将共享内存从进程的地址空间中分离。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* shmat/shmdt */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span>*<span class="title">shmat</span><span class="params">(<span class="type">int</span> shm_id,<span class="type">const</span> <span class="type">void</span>*shm_addr,<span class="type">int</span> shmflg)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span>*shm_addr)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">shm_id -- 共享内存标识符</span></span><br><span class="line"><span class="comment">shm_addr -- 指定将共享内存关联到进程的哪块地址空间</span></span><br><span class="line"><span class="comment">shmflg -- 设置可选参数，设置函数行为</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="shmctl函数"><a href="#shmctl函数" class="headerlink" title="shmctl函数"></a>shmctl函数</h3><blockquote><p>控制内存属性</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmctl</span><span class="params">(<span class="type">int</span> shm_id,<span class="type">int</span> command,<span class="keyword">struct</span> shmid_ds*buf)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">shm_id参数是由shmget调用返回的共享内存标识符</span></span><br><span class="line"><span class="comment">command参数指定要执行的命令</span></span><br><span class="line"><span class="comment">buf是进程信息</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="共享内存的POSIX方法"><a href="#共享内存的POSIX方法" class="headerlink" title="共享内存的POSIX方法"></a>共享内存的POSIX方法</h3><h5 id="shm-open函数"><a href="#shm-open函数" class="headerlink" title="shm_open函数"></a>shm_open函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shm_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*name,<span class="type">int</span> oflag,<span class="type">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数解释：</span></span><br><span class="line"><span class="comment">name参数指定要创建/打开的共享内存对象</span></span><br><span class="line"><span class="comment">oflag参数指定创建方式</span></span><br><span class="line"><span class="comment">mode参数设置权限</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="shm-unlink函数"><a href="#shm-unlink函数" class="headerlink" title="shm_unlink函数"></a>shm_unlink函数</h4><blockquote><p>该函数将name参数指定的共享内存对象标记为等待删除。当所有使用该共享内存对象的进程都使用ummap将它从进程中分离之后，系统将销毁这个共享内存对象所占据的资源</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shm_unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*name)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>如果代码中使用了上述POSIX共享内存函数，则编译的时候需要指定链接选项-lrt。</p></blockquote><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>待完善。。。</p>]]></content:encoded>
      
      
      
      
      <comments>http://ycg0508.com/2023/11/14/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title></title>
      <link>http://ycg0508.com/2023/11/07/%E4%BF%A1%E5%8F%B7/</link>
      <guid>http://ycg0508.com/2023/11/07/%E4%BF%A1%E5%8F%B7/</guid>
      <pubDate>Tue, 07 Nov 2023 10:37:04 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;title:信号&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;信号&quot;&gt;&lt;a href=&quot;#信号&quot; class=&quot;headerlink&quot; title=&quot;信号&quot;&gt;&lt;/a&gt;信号&lt;/h1&gt;&lt;h2 id=&quot;发送信号&quot;&gt;&lt;a href=&quot;#发送信号&quot; class=&quot;headerlink&quot; tit</description>
        
      
      
      
      <content:encoded><![CDATA[<p>title:信号</p><hr><h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><h2 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 发送信号函数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kill</span><span class="params">(<span class="type">pid_t</span> pid,<span class="type">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>该函数把信号sig发送给目标进程；目标进程由pid参数指定，其可能的取值及含义如表10-1所示。</p></blockquote><p>![image-20231107182919105](C:\Users\Yan chang guo\AppData\Roaming\Typora\typora-user-images\image-20231107182919105.png)</p><blockquote><p>Linux定义的信号值都大于0，如果sig取值为0，则kill函数不发送任何信号。但将sig设置为0可以用来检测目标进程或进程组是否存在，因为检查工作总是在信号发送之前就执行。不过这种检测方式是不可靠的。一方面由于进程PID的回绕，可能导致被检测的PID不是我们期望的进程的PID；另一方面，这种检测方法不是原子操作。该函数成功时返回0，失败则返回-1并设置errno。几种可能的errno如表10-2所示。</p></blockquote><p>![image-20231107183138444](C:\Users\Yan chang guo\AppData\Roaming\Typora\typora-user-images\image-20231107183138444.png)</p><h3 id="信号的处理方式"><a href="#信号的处理方式" class="headerlink" title="信号的处理方式"></a>信号的处理方式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 信号处理函数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*<span class="type">__sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span><span class="comment">/* 函数指针 */</span></span></span><br></pre></td></tr></table></figure><blockquote><p>除了用户自定义信号处理函数外，bits&#x2F;signum.h头文件中还定义了信号的两种其他处理方式——SIG_IGN和SIG_DEL：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span>＜bits/signum.h＞</span></span><br><span class="line"><span class="comment">/* SIG_DFL表示使用信号的默认处理方式 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIG_DFL((__sighandler_t)0)</span></span><br><span class="line"><span class="comment">/* SIG_IGN表示忽略目标信号 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIG_IGN((__sighandler_t)1)</span></span><br></pre></td></tr></table></figure><blockquote><p>信号的默认处理方式有如下几种：结束进程（Term）、忽略信号（Ign）、结束进程并生成核心转储文件（Core）、暂停进程（Stop），以及继续进程（Cont）。</p></blockquote><h2 id="信号函数"><a href="#信号函数" class="headerlink" title="信号函数"></a>信号函数</h2><h3 id="signal函数"><a href="#signal函数" class="headerlink" title="signal函数"></a>signal函数</h3><blockquote><p>信号处理函数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">_sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="type">int</span> sig, <span class="type">_sighandler_t</span> _handler)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数参数</span></span><br><span class="line"><span class="comment">sig -- sig是要捕获的信号类型</span></span><br><span class="line"><span class="comment">_handler -- 函数指针，用于指定信号sig的处理函数</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction"></a>sigaction</h2><blockquote><p>更好的信号处理函数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigaction</span><span class="params">(<span class="type">int</span> sig, <span class="type">const</span> <span class="keyword">struct</span> sigaction* act, <span class="keyword">struct</span> sigaction* oact)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数参数</span></span><br><span class="line"><span class="comment">sig -- 要捕获的信号类型</span></span><br><span class="line"><span class="comment">act -- 指定新的信号处理方式</span></span><br><span class="line"><span class="comment">oact -- 输出信号先前的处理方式（如果不为nullptu）</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      
      <comments>http://ycg0508.com/2023/11/07/%E4%BF%A1%E5%8F%B7/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>关于socket的阻塞/非阻塞和ET的响应</title>
      <link>http://ycg0508.com/2023/11/03/%E5%85%B3%E4%BA%8Esocket%E7%9A%84%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E/</link>
      <guid>http://ycg0508.com/2023/11/03/%E5%85%B3%E4%BA%8Esocket%E7%9A%84%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E/</guid>
      <pubDate>Fri, 03 Nov 2023 10:49:38 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;关于socket的阻塞和非阻塞&quot;&gt;&lt;a href=&quot;#关于socket的阻塞和非阻塞&quot; class=&quot;headerlink&quot; title=&quot;关于socket的阻塞和非阻塞&quot;&gt;&lt;/a&gt;关于socket的阻塞和非阻塞&lt;/h1&gt;&lt;h2 id=&quot;阻塞和非阻塞原理及返回值&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="关于socket的阻塞和非阻塞"><a href="#关于socket的阻塞和非阻塞" class="headerlink" title="关于socket的阻塞和非阻塞"></a>关于socket的阻塞和非阻塞</h1><h2 id="阻塞和非阻塞原理及返回值"><a href="#阻塞和非阻塞原理及返回值" class="headerlink" title="阻塞和非阻塞原理及返回值"></a>阻塞和非阻塞原理及返回值</h2><blockquote><p>socket在创建时默认是阻塞的，可以通过给socket系统调用的第2个参数传递SOCK_NONBLOCK标志，或者通过fcntl系统调用的F_SETFL命令，将其设置为非阻塞的。</p><p>针对阻塞I&#x2F;O执行的系统调用可能因为无法立即完成而被操作系统挂起，直到等待的事件发生为止。比如，客户端通过connect向服务器发起连接时，connect将首先发送同步报文段给服务器，然后等待服务器返回确认报文段。如果服务器的确认报文段没有立即到达客户端，则connect调用将被挂起，直到客户端收到确认报文段并唤醒connect调用。socket的基础API中，可能被阻塞的系统调用包括accept、send、recv和connect。</p><p>针对非阻塞的I&#x2F;O执行的系统调用总是立即被返回的，而不会去管事件发生没有，如果没有事件发生就返回-1，然后根据返回-1设置的errno来区分情况，对accept、send和recv而言，事件未发生时errno通常被设置成EAGAIN（意为“再来一次”）或者EWOULDBLOCK（意为“期望阻塞”）；对connect而言，errno则被设置成EINPROGRESS（意为“在处理中”）。</p></blockquote><h2 id="阻塞I-O-和-非阻塞I-O-优缺点对比"><a href="#阻塞I-O-和-非阻塞I-O-优缺点对比" class="headerlink" title="阻塞I&#x2F;O 和 非阻塞I&#x2F;O 优缺点对比"></a>阻塞I&#x2F;O 和 非阻塞I&#x2F;O 优缺点对比</h2><blockquote><p>阻塞I&#x2F;O简单，适用于文件系统，连接少，需要传输大文件，编写简单，容易使用，性能较差</p><p>非阻塞I&#x2F;O较难，适用于交互系统，连接多，需要频繁进行I&#x2F;O，编写较复杂</p></blockquote><h2 id="关于eoll的et模式"><a href="#关于eoll的et模式" class="headerlink" title="关于eoll的et模式"></a>关于eoll的et模式</h2><p>假设一种情况，服务器端A向客户端B发送数据，B采用非阻塞I&#x2F;O，一次没有读取完数据，那么A再次向B发送数据的时候会触发B的事件，再次读取数据吗？</p><blockquote><p>答案是会的。</p><p>et模式触发是这样说的：由不可读变为可读时触发读事件，由不可写变为可写触发写事件。</p><p>第一次没有读取完数据就从读事件变为了不可读事件，第二次继续epoll_wait检测的时候发现又有数据发送过来了就会再次触发事件变为读事件，但是如果内核缓冲区中数据没有被读取完，然后又没有新的数据发送过来，那么et模式下的文件描述符是不会继续触发事件的。</p></blockquote>]]></content:encoded>
      
      
      
      
      <comments>http://ycg0508.com/2023/11/03/%E5%85%B3%E4%BA%8Esocket%E7%9A%84%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title></title>
      <link>http://ycg0508.com/2023/11/01/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</link>
      <guid>http://ycg0508.com/2023/11/01/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</guid>
      <pubDate>Wed, 01 Nov 2023 15:00:04 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;title:字符串常用函数&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;字符串常用函数&quot;&gt;&lt;a href=&quot;#字符串常用函数&quot; class=&quot;headerlink&quot; title=&quot;字符串常用函数&quot;&gt;&lt;/a&gt;字符串常用函数&lt;/h1&gt;&lt;h2 id=&quot;strpbrk函数&quot;&gt;&lt;a href=</description>
        
      
      
      
      <content:encoded><![CDATA[<p>title:字符串常用函数</p><hr><h1 id="字符串常用函数"><a href="#字符串常用函数" class="headerlink" title="字符串常用函数"></a>字符串常用函数</h1><h2 id="strpbrk函数"><a href="#strpbrk函数" class="headerlink" title="strpbrk函数"></a>strpbrk函数</h2><blockquote><p>strpbrk函数用于在一个字符串中查找字符集合中的任意字符的第一个匹配项，返回指向第一个匹配字符的指针</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 函数原型 */</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strpbrk</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str,<span class="type">const</span> <span class="type">char</span>* str2)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="strcasecmp函数"><a href="#strcasecmp函数" class="headerlink" title="strcasecmp函数"></a>strcasecmp函数</h2><blockquote><p>​strcasecmp函数用于判断两个字符串是否相等，不考虑字符大小写的差异，相等返回0，第一个字符串小于第二个字符串返回负值，反之返回正数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 函数原型 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">strcasecmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* sz1, <span class="type">const</span> <span class="type">char</span>* sz2)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="strspn函数"><a href="#strspn函数" class="headerlink" title="strspn函数"></a>strspn函数</h2><blockquote><p>strspn函数检索字符串str1中第一个不在字符串str2中出现的字符下标。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 函数原型 */</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">strspn</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span></span></span><br></pre></td></tr></table></figure><h2 id="basename函数"><a href="#basename函数" class="headerlink" title="basename函数"></a>basename函数</h2><blockquote><p>文件名处理函数，用于在字符串目录中提取出文件名部分。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">basename</span><span class="params">(<span class="type">char</span>* filename)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* HTTP请求 */</span></span><br><span class="line"><span class="comment">/* GET方式 */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 请求方式 请求url 请求协议版本</span></span><br><span class="line"><span class="comment">GET http://www.baidu.com/index.html HTTP/1.0/r/n</span></span><br><span class="line"><span class="comment">// 请求IP:端口/域名</span></span><br><span class="line"><span class="comment">Host:www.baidu.com/r/n</span></span><br><span class="line"><span class="comment">Connection:close</span></span><br><span class="line"><span class="comment">/* 第一行为请求行，2-4行都是头部字段 */</span></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">GET / HTTP/1.1</span></span><br><span class="line"><span class="comment">Host: 127.0.0.1:8080</span></span><br><span class="line"><span class="comment">User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0</span></span><br><span class="line"><span class="comment">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/</span>*;q=<span class="number">0.8</span></span><br><span class="line">Accept-Language: zh-CN,zh;q=<span class="number">0.8</span>,zh-TW;q=<span class="number">0.7</span>,zh-HK;q=<span class="number">0.5</span>,en-US;q=<span class="number">0.3</span>,en;q=<span class="number">0.2</span></span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Upgrade-Insecure-Requests: <span class="number">1</span></span><br><span class="line">*/</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* HTTP应答 */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">HTTP/1.0 200 OK</span></span><br><span class="line"><span class="comment">Server:BWS/1.0</span></span><br><span class="line"><span class="comment">Content-Length:8024</span></span><br><span class="line"><span class="comment">Content-Type:text/html;charset=gbk</span></span><br><span class="line"><span class="comment">SetCookie:BAIDUID=A5B6C72D68CF639CE8896FD79A03FBD8:FG=1;expires=Wed,04-</span></span><br><span class="line"><span class="comment">Jul-42 00:10:47 GMT;path=/;domain=.baidu.com</span></span><br><span class="line"><span class="comment">Via:1.0 localhost(squid/3.0 STABLE18)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      
      <comments>http://ycg0508.com/2023/11/01/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>服务器模型</title>
      <link>http://ycg0508.com/2023/10/30/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%9E%8B/</link>
      <guid>http://ycg0508.com/2023/10/30/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%9E%8B/</guid>
      <pubDate>Mon, 30 Oct 2023 12:37:27 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;服务器模型&quot;&gt;&lt;a href=&quot;#服务器模型&quot; class=&quot;headerlink&quot; title=&quot;服务器模型&quot;&gt;&lt;/a&gt;服务器模型&lt;/h1&gt;&lt;h2 id=&quot;C-S模型&quot;&gt;&lt;a href=&quot;#C-S模型&quot; class=&quot;headerlink&quot; title=&quot;C&amp;#</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="服务器模型"><a href="#服务器模型" class="headerlink" title="服务器模型"></a>服务器模型</h1><h2 id="C-S模型"><a href="#C-S模型" class="headerlink" title="C&#x2F;S模型"></a>C&#x2F;S模型</h2><blockquote><p>C&#x2F;S模型（客户端&#x2F;&#x2F;服务器模型），以服务器为主，所有客户端都依赖于服务器的模型。</p></blockquote><h2 id="P2P模型"><a href="#P2P模型" class="headerlink" title="P2P模型"></a>P2P模型</h2><blockquote><p>P2P模型（点对点模型）网络上的所有主机都处于对等状态，</p></blockquote><p>服务器编程框架</p><blockquote><p>基本模块：</p></blockquote><p>![image-20231030190906335](C:\Users\Yan chang guo\AppData\Roaming\Typora\typora-user-images\image-20231030190906335.png)</p><p>![image-20231030190917780](C:\Users\Yan chang guo\AppData\Roaming\Typora\typora-user-images\image-20231030190917780.png)</p><h2 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I&#x2F;O模型"></a>I&#x2F;O模型</h2><blockquote><p>I&#x2F;O模型同步I&#x2F;O模型和异步I&#x2F;O模型</p><p>同步I&#x2F;O分为阻塞I&#x2F;O、非阻塞I&#x2F;O、I&#x2F;O复用、信号驱动I&#x2F;O</p></blockquote><h3 id="非阻塞I-O"><a href="#非阻塞I-O" class="headerlink" title="非阻塞I&#x2F;O"></a>非阻塞I&#x2F;O</h3><blockquote><p>非阻塞的概念：通过给socket系统调用的第2个参数传递SOCK_NONBLOCK标志，或者通过fcntl系统调用的F_SETFL命令，将其设置为非阻塞的。</p><p>针对非阻塞I&#x2F;O执行的系统调用则总是立即返回，而不管事件是否已经发生。如果事件没有立即发生，这些系统调用就返回-1，和出错的情况一样。此时我们必须根据errno来区分这两种情况。对accept、send和recv而言，事件未发生时errno通常被设置成EAGAIN（意为“再来一次”）或者EWOULDBLOCK（意为“期望阻塞”）；对connect而言，errno则被设置成EINPROGRESS（意为“在处理中”）</p><p>很显然，我们只有在事件已经发生的情况下操作非阻塞I&#x2F;O（读、写等），才能提高程序的效率。因此，非阻塞I&#x2F;O通常要和其他I&#x2F;O通知机制一起使用，比如I&#x2F;O复用和SIGIO信号。</p></blockquote><h3 id="I-O复用"><a href="#I-O复用" class="headerlink" title="I&#x2F;O复用"></a>I&#x2F;O复用</h3><blockquote><p>I&#x2F;O复用是最常使用的I&#x2F;O通知机制。它指的是，应用程序通过I&#x2F;O复用函数向内核注册一组事件，内核通过I&#x2F;O复用函数把其中就绪的事件通知给应用程序。Linux上常用的I&#x2F;O复用函数是select、poll和epoll_wait，我们将在第9章详细讨论它们。需要指出的是，I&#x2F;O复用函数本身是阻塞的，它们能提高程序效率的原因在于它们具有同时监听多个I&#x2F;O事件的能力。</p></blockquote><h3 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I&#x2F;O"></a>异步I&#x2F;O</h3><blockquote><p>异步I&#x2F;O的读写操作总是立即返回，而不论I&#x2F;O是否是阻塞的，因为真正的读写操作已经由内核接管。也就是说，同步I&#x2F;O模型要求用户代码自行执行I&#x2F;O操作（将数据从内核缓冲区读入用户缓冲区，或将数据从用户缓冲区写入内核缓冲区），而异步I&#x2F;O机制则由内核来执行I&#x2F;O操作（数据在内核缓冲区和用户缓冲区之间的移动是由内核在“后台”完成的）。你可以这样认为，同步I&#x2F;O向应用程序通知的是I&#x2F;O就绪事件，而异步I&#x2F;O向应用程序通知的是I&#x2F;O完成事件。Linux环境下，aio.h头文件中定义的函数提供了对异步I&#x2F;O的支持。</p></blockquote><p>![image-20231030193710849](C:\Users\Yan chang guo\AppData\Roaming\Typora\typora-user-images\image-20231030193710849.png)</p><h2 id="Reactor-Proactor"><a href="#Reactor-Proactor" class="headerlink" title="Reactor&#x2F;Proactor"></a>Reactor&#x2F;Proactor</h2><blockquote><p>见书8.4.1 和 8.4.2</p></blockquote><h2 id="模拟Proactor"><a href="#模拟Proactor" class="headerlink" title="模拟Proactor"></a>模拟Proactor</h2><blockquote><p>见书8.4.3</p></blockquote><h2 id="半同步-半异步模式"><a href="#半同步-半异步模式" class="headerlink" title="半同步&#x2F;半异步模式"></a>半同步&#x2F;半异步模式</h2><blockquote><p>见书8.5.1</p></blockquote><h2 id="半同步-半反应堆模式"><a href="#半同步-半反应堆模式" class="headerlink" title="半同步&#x2F;半反应堆模式"></a>半同步&#x2F;半反应堆模式</h2><blockquote><p>见书8.5.1(半同步&#x2F;半异步变种模式)</p></blockquote><h2 id="领导者-追随者模式"><a href="#领导者-追随者模式" class="headerlink" title="领导者&#x2F;追随者模式"></a>领导者&#x2F;追随者模式</h2><blockquote><p>见书8.5.2</p></blockquote><h2 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h2><blockquote><p>逻辑单元的一种高效编程方法</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 状态独立的有限状态机 */</span></span><br><span class="line"><span class="comment">/* 特点是该状态机的每个状态之间都是相互独立的，即状态之间没有相互转移 */</span></span><br><span class="line"><span class="built_in">STATE_MACHINE</span>(Package_pack)</span><br><span class="line">&#123;</span><br><span class="line">    PackageType_type=_pack.<span class="built_in">GetType</span>();</span><br><span class="line">    <span class="keyword">switch</span>(_type)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> type_A:</span><br><span class="line">            <span class="built_in">process_package_A</span>(_pack);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> type_B:</span><br><span class="line">            <span class="built_in">process_package_B</span>(_pack);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 带状态转移的有限状态机 */</span></span><br><span class="line">&#123;</span><br><span class="line">State cur_State=type_A;</span><br><span class="line">    <span class="keyword">while</span>(cur_State!=type_C)</span><br><span class="line">    &#123;</span><br><span class="line">        Package_pack=<span class="built_in">getNewPackage</span>();</span><br><span class="line">        <span class="keyword">switch</span>(cur_State)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> type_A:</span><br><span class="line">                <span class="built_in">process_package_state_A</span>(_pack);</span><br><span class="line">                cur_State=type_B;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> type_B:</span><br><span class="line">                <span class="built_in">process_package_state_B</span>(_pack);</span><br><span class="line">                cur_State=type_C;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>主从状态机解析HTTP请求报文：</p><p>代码见git&#x2F;8-6</p></blockquote>]]></content:encoded>
      
      
      
      
      <comments>http://ycg0508.com/2023/10/30/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%9E%8B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>日志系统</title>
      <link>http://ycg0508.com/2023/10/30/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</link>
      <guid>http://ycg0508.com/2023/10/30/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</guid>
      <pubDate>Mon, 30 Oct 2023 11:19:41 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;日志系统&quot;&gt;&lt;a href=&quot;#日志系统&quot; class=&quot;headerlink&quot; title=&quot;日志系统&quot;&gt;&lt;/a&gt;日志系统&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;syslog函数&quot;&gt;&lt;a href=&quot;#syslog函数&quot; class=&quot;headerl</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h1><p>[TOC]</p><h2 id="syslog函数"><a href="#syslog函数" class="headerlink" title="syslog函数"></a>syslog函数</h2><blockquote><p>Linux提供的守护进程(后台进程)，用来处理系统日志</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 函数定义 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">syslog</span><span class="params">(<span class="type">int</span> priority, <span class="type">const</span> <span class="type">char</span>* message, ...)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">priority -- 设施值与日志级别的按位或</span></span><br><span class="line"><span class="comment">message 和 ... 表示结构化输出</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="openlog函数"><a href="#openlog函数" class="headerlink" title="openlog函数"></a>openlog函数</h2><blockquote><p>改变 syslog 的默认输出方式</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span>＜syslog.h＞</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">openlog</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*ident,<span class="type">int</span> logopt,<span class="type">int</span> facility)</span></span>;</span><br><span class="line"><span class="comment">/* 参数解释 */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ident参数指定的字符串将被添加到日志消息的日期和时间之后，</span></span><br><span class="line"><span class="comment">它通常被设置为程序的名字。</span></span><br><span class="line"><span class="comment">logopt参数对后续syslog调用的行为进行配置</span></span><br><span class="line"><span class="comment">facility参数可用来修改syslog函数中的默认设施值。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="setlogmask函数"><a href="#setlogmask函数" class="headerlink" title="setlogmask函数"></a>setlogmask函数</h2><blockquote><p>设置日志掩码级别</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span>＜syslog.h＞</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setlogmask</span><span class="params">(<span class="type">int</span> maskpri)</span></span>;</span><br><span class="line"><span class="comment">/* 参数解释 */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">maskpri -- 指定新的日志掩码值，成功返回调用进程设置前的日志掩码值</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="closelog函数"><a href="#closelog函数" class="headerlink" title="closelog函数"></a>closelog函数</h2><blockquote><p>关闭日志文件</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span>＜syslog.h＞</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">closelog</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h2 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h2><h3 id="UID-EUID-GID-EGID"><a href="#UID-EUID-GID-EGID" class="headerlink" title="UID\EUID\GID\EGID"></a>UID\EUID\GID\EGID</h3><blockquote><p>用户信息对于服务器程序的安全性来说是很重要的，比如大部分</p><p>服务器就必须以root身份启动，但不能以root身份运行。下面这一组函</p><p>数可以获取和设置当前进程的真实用户ID（UID）、有效用户</p><p>ID（EUID）、真实组ID（GID）和有效组ID（EGID）：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="type">uid_t</span> <span class="title">getuid</span><span class="params">()</span></span>;<span class="comment">/*获取真实用户ID*/</span></span><br><span class="line"><span class="function"><span class="type">uid_t</span> <span class="title">geteuid</span><span class="params">()</span></span>;<span class="comment">/*获取有效用户ID*/</span></span><br><span class="line"><span class="function"><span class="type">gid_t</span> <span class="title">getgid</span><span class="params">()</span></span>;<span class="comment">/*获取真实组ID*/</span></span><br><span class="line"><span class="function"><span class="type">gid_t</span> <span class="title">getegid</span><span class="params">()</span></span>;<span class="comment">/*获取有效组ID*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setuid</span><span class="params">(<span class="type">uid_t</span> uid)</span></span>;<span class="comment">/*设置真实用户ID*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">seteuid</span><span class="params">(<span class="type">uid_t</span> uid)</span></span>;<span class="comment">/*设置有效用户ID*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setgid</span><span class="params">(<span class="type">gid_t</span> gid)</span></span>;<span class="comment">/*设置真实组ID*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setegid</span><span class="params">(<span class="type">gid_t</span> gid)</span></span>;<span class="comment">/*设置有效组ID*/</span></span><br></pre></td></tr></table></figure><h2 id="进程间关系"><a href="#进程间关系" class="headerlink" title="进程间关系"></a>进程间关系</h2><blockquote><p>进程组ID(PGID)，进程ID(PID)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 函数定义 */</span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">getpgid</span><span class="params">(<span class="type">oid_t</span> pid)</span></span>;</span><br><span class="line"><span class="comment">/* 该函数用于获取指定进程的PGID，该函数成功时返回进程pid所属进程组的PGID */</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 函数定义 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setpgid</span><span class="params">(<span class="type">pid_t</span> pid,<span class="type">pid_t</span> pgid)</span></span>;</span><br><span class="line"><span class="comment">/*  该函数将PID为pid的进程的PGID设置为pgid。如果pid和pgid相同，则由pid指定的进程将被设置为进程组首领；如果pid为0，则表示设置当前进程的PGID为pgid；如果pgid为0，则使用pid作为目标PGID。setpgid函数成功时返回0，失败则返回-1并设置errno。一个进程只能设置自己或者其子进程的PGID。并且，当子进程调用exec系列函数后，我们也不能再在父进程中对它设置PGID。*/</span></span><br></pre></td></tr></table></figure><h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><blockquote><p>一些相关联的进程组组成的会话，会话ID(PID)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 函数定义 */</span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">setsid</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>一图描述进程、进程组、会话之间的关系</p></blockquote><p>![image-20231030104451976](C:\Users\Yan chang guo\AppData\Roaming\Typora\typora-user-images\image-20231030104451976.png)</p><h3 id="系统资源限制"><a href="#系统资源限制" class="headerlink" title="系统资源限制"></a>系统资源限制</h3><blockquote><p>通过函数读取&#x2F;修改系统限制资源。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 函数定义 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getlimit</span><span class="params">(<span class="type">int</span> resource, <span class="keyword">struct</span> rlimit* rlim)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setlimit</span><span class="params">(<span class="type">int</span> resource, <span class="type">const</span> <span class="keyword">struct</span> rlimit* rlim)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">resource -- 指定资源限制类型</span></span><br><span class="line"><span class="comment">rlimit -- 描述资源级别</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>![image-20231030110903049](C:\Users\Yan chang guo\AppData\Roaming\Typora\typora-user-images\image-20231030110903049.png)</p><p>改变工作目录和根目录</p><blockquote><p>获取进程当前工作目录和改变进程工作目录的函数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 函数定义 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="type">char</span>*<span class="title">getcwd</span><span class="params">(<span class="type">char</span>*buf,<span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*path)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">path -- 指定要切换到的目标目录</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 切换进程根目录 */</span></span><br><span class="line"><span class="comment">/* 只有特权进程才能改变根目录 set-user-id */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">chroot</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*path)</span></span>;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      
      <comments>http://ycg0508.com/2023/10/30/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>GDB调试</title>
      <link>http://ycg0508.com/2023/10/30/GDB%E8%B0%83%E8%AF%95/</link>
      <guid>http://ycg0508.com/2023/10/30/GDB%E8%B0%83%E8%AF%95/</guid>
      <pubDate>Mon, 30 Oct 2023 08:37:28 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;GDB调试&quot;&gt;&lt;a href=&quot;#GDB调试&quot; class=&quot;headerlink&quot; title=&quot;GDB调试&quot;&gt;&lt;/a&gt;GDB调试&lt;/h1&gt;&lt;p&gt;![image-20231030163502524](C:&#92;Users&#92;Yan chang guo&#92;AppData&#92;</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="GDB调试"><a href="#GDB调试" class="headerlink" title="GDB调试"></a>GDB调试</h1><p>![image-20231030163502524](C:\Users\Yan chang guo\AppData\Roaming\Typora\typora-user-images\image-20231030163502524.png)</p><table><thead><tr><th>调试命令</th><th>作用</th><th></th></tr></thead><tbody><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table>]]></content:encoded>
      
      
      
      
      <comments>http://ycg0508.com/2023/10/30/GDB%E8%B0%83%E8%AF%95/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>高级IO函数</title>
      <link>http://ycg0508.com/2023/10/27/%E9%AB%98%E7%BA%A7IO%E5%87%BD%E6%95%B0/</link>
      <guid>http://ycg0508.com/2023/10/27/%E9%AB%98%E7%BA%A7IO%E5%87%BD%E6%95%B0/</guid>
      <pubDate>Fri, 27 Oct 2023 15:25:21 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;高级IO函数&quot;&gt;&lt;a href=&quot;#高级IO函数&quot; class=&quot;headerlink&quot; title=&quot;高级IO函数&quot;&gt;&lt;/a&gt;高级IO函数&lt;/h1&gt;&lt;h2 id=&quot;pipe管道&quot;&gt;&lt;a href=&quot;#pipe管道&quot; class=&quot;hea</description>
        
      
      
      
      <content:encoded><![CDATA[<p>[TOC]</p><h1 id="高级IO函数"><a href="#高级IO函数" class="headerlink" title="高级IO函数"></a>高级IO函数</h1><h2 id="pipe管道"><a href="#pipe管道" class="headerlink" title="pipe管道"></a>pipe管道</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 函数原型 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pipe</span><span class="params">(<span class="type">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>定义：</p><p>​函数执行成功返回0，并将一个打开的文件描述符填入指向的数组。</p><p>​fd[0] 和 fd[1] 分别构成管道的两端，fd[1] 写入的数据只能从 fd[0] 读出，fd[0] 为读端，fd[1] 为写端，如果要实现双向的数据传输，就需要使用两个管道，默认情况下，这一对文件描述符都是阻塞的，此时如果我们使用read系统调用来读取一个空的管道，则read被阻塞，相同的，使用write函数调用来往一个满的管道中写入数据，则write亦将被阻塞(&#x2F;设置为非阻塞则read和write会有不同的行为)。</p><p>​如果管道的写端文件描述符 fd[1] 的引用计数减少至0，即没有文件描述符向管道中写入数据，则针对该管道的fd[0] 的read操作将返回0，即读取到了文件结束标记，反之，管道的读端文件描述符 fd[0] 的引用计数减少至0，即没有进程需要从管道读取数据。则针对该管道的写端文件描述符 fd[1] write返回0，操作失败，引发sigpipe信号。</p><p>​管道内部传输的数据采用字节流的方式，管道本身有容量限制，根据Linux2.6.11版本起，默认大小为65536字节。</p></blockquote><h2 id="socketpair双向管道"><a href="#socketpair双向管道" class="headerlink" title="socketpair双向管道"></a>socketpair双向管道</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 函数定义 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socketpair</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> proticol, <span class="type">int</span> fd[<span class="number">2</span>])</span></span>;<span class="comment">// 创建双向管道</span></span><br><span class="line"><span class="comment">/* 参数解释 */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">domain,type,protocol参数与socket函数一样，但只能使用UNIX本地域协议族AF_UNIX</span></span><br><span class="line"><span class="comment">fd -- 创建管道的文件描述符，不同点在于这对文件描述符都是可读可写的</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="dup-dup2复制文件描述符"><a href="#dup-dup2复制文件描述符" class="headerlink" title="dup&#x2F;dup2复制文件描述符"></a>dup&#x2F;dup2复制文件描述符</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 函数原型 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dup</span><span class="params">(<span class="type">int</span> file_descriptor)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dup2</span><span class="params">(<span class="type">int</span> file_descriptor_one, <span class="type">int</span> file_descriptor_two)</span></span>;</span><br><span class="line"><span class="comment">/* 函数解释 */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">dup函数创建一个新的文件描述符，指向被复制文件描述符的相同的文件、管道和网络连接，按序后取，取当前系统可用最小文件描述符，失败返回-1，设置error</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="零拷贝函数"><a href="#零拷贝函数" class="headerlink" title="零拷贝函数"></a>零拷贝函数</h2><h3 id="sendfile文件传输"><a href="#sendfile文件传输" class="headerlink" title="sendfile文件传输"></a>sendfile文件传输</h3><blockquote><p>sendfile直接在两个文件描述符之间传递数据，属于内核操作，不需要内核缓冲区和用户缓冲区的数据拷贝，效率很高</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 函数定义 */</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendfile</span><span class="params">(<span class="type">int</span> out_fd, <span class="type">int</span> in_fd, <span class="type">off_t</span>* offset, <span class="type">size_t</span> count)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数解释：</span></span><br><span class="line"><span class="comment">in_fd -- 待读出的文件描述符。</span></span><br><span class="line"><span class="comment">out_fd -- 待写入的文件描述符</span></span><br><span class="line"><span class="comment">offset -- 指定从读入文件流的哪个位置开始读</span></span><br><span class="line"><span class="comment">count -- 指定在文件描述符in_fd 和 out_fd之间传输的字节数</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="mmap-munmmap共享内存"><a href="#mmap-munmmap共享内存" class="headerlink" title="mmap&#x2F;munmmap共享内存"></a>mmap&#x2F;munmmap共享内存</h3><blockquote><p>函数概念：</p><p>mmap函数用于申请一段内存空间，可以将这段内存作为进程间的通信的共享内存，也可以将文件映射到这段内存。执行成功返回指向目标内存区域的指针，失败返回MAP_FAILED((void*)-1)，并设置error。</p><p>munmap函数用于释放mmap创建的内存空间，执行成功返回0，执行失败返回-1。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 函数定义 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="comment">/* mmap */</span></span><br><span class="line"><span class="function"><span class="type">void</span> * <span class="title">mmap</span><span class="params">(<span class="type">void</span>* start, <span class="type">size_t</span> length, <span class="type">int</span> port, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="comment">/* munmap */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">munmap</span><span class="params">(<span class="type">void</span>* start, <span class="type">size_t</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数解释</span></span><br><span class="line"><span class="comment">start -- 允许使用特定的地址作为这段内存的起始地址，被设置为NULL，则由系统自动分配地址。</span></span><br><span class="line"><span class="comment">length -- 指定内存段的长度</span></span><br><span class="line"><span class="comment">prot -- 指定内存段的访问权限，具体可看参数列表1</span></span><br><span class="line"><span class="comment">flags -- 控制内存段内容被修改后程序的行为，具体可看参数列表2</span></span><br><span class="line"><span class="comment">fd -- 被映射文件对应的文件描述符</span></span><br><span class="line"><span class="comment">offset -- 设置从文件的何处开始映射</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="splice函数"><a href="#splice函数" class="headerlink" title="splice函数"></a>splice函数</h3><blockquote><p>函数概念：</p><p>splice函数用于在两个文件描述符之间传输数据，也是零拷贝操作。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 函数定义 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">splice</span><span class="params">(<span class="type">int</span> fd_in,<span class="type">loff_t</span>*off_in,<span class="type">int</span></span></span></span><br><span class="line"><span class="params"><span class="function">fd_out,<span class="type">loff_t</span>*off_out,<span class="type">size_t</span> len,<span class="type">unsigned</span> <span class="type">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">6-6节</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="tee函数"><a href="#tee函数" class="headerlink" title="tee函数"></a>tee函数</h3><blockquote><p>函数概念</p><p>tee函数在两个管道文件描述符之间复制数据，也是零拷贝操作。它不消耗数据，因此源文件描述符上的数据仍然可以用于后续的读操作。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 函数定义 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">tee</span><span class="params">(<span class="type">int</span> fd_in, <span class="type">int</span> fd_out, <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">/* 参数解释 */</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">该函数的参数的含义与splice相同（但fd_in和fd_out必须都是管道</span></span><br><span class="line"><span class="comment">文件描述符） </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="fcntl函数"><a href="#fcntl函数" class="headerlink" title="fcntl函数"></a>fcntl函数</h3><blockquote><p>函数概念：</p><p>fcntl函数提供对文件描述符的各种控制操作，一般用于将文件描述符设置为非阻塞的。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 函数定义 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fcntl</span><span class="params">(<span class="type">int</span> fd,cmd,...)</span></span>;</span><br><span class="line"><span class="comment">/* 参数解释 */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">fd -- 被操作的文件描述符</span></span><br><span class="line"><span class="comment">cmd -- 指定操作</span></span><br><span class="line"><span class="comment">... -- 可变参数，根据实际情况加参</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>![image-20231029192320278](C:\Users\Yan chang guo\AppData\Roaming\Typora\typora-user-images\image-20231029192320278.png)</p>]]></content:encoded>
      
      
      
      
      <comments>http://ycg0508.com/2023/10/27/%E9%AB%98%E7%BA%A7IO%E5%87%BD%E6%95%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>网络编程基础</title>
      <link>http://ycg0508.com/2023/10/27/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</link>
      <guid>http://ycg0508.com/2023/10/27/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</guid>
      <pubDate>Fri, 27 Oct 2023 13:26:27 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;TCP-IP协议结构体&quot;&gt;&lt;a href=&quot;#TCP-IP协议结构体&quot; class=&quot;headerlink&quot; title=&quot;TCP&amp;#x2F;IP协议结构体&quot;&gt;&lt;/a&gt;TCP&amp;#x2F;IP协议结构体&lt;/h2&gt;&lt;p&gt;专用socket地址结构体&lt;/p&gt;
&lt;p&gt;​		</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="TCP-IP协议结构体"><a href="#TCP-IP协议结构体" class="headerlink" title="TCP&#x2F;IP协议结构体"></a>TCP&#x2F;IP协议结构体</h2><p>专用socket地址结构体</p><p>​UNIX本地域协议专用socket结构体地址</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_un</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sin_family;<span class="comment">// 地址族</span></span><br><span class="line">    <span class="type">char</span> sun_path[<span class="number">108</span>];<span class="comment">// 文件路径名</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="TCP-IP协议族结构体"><a href="#TCP-IP协议族结构体" class="headerlink" title="TCP&#x2F;IP协议族结构体"></a>TCP&#x2F;IP协议族结构体</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* IPV4 */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">sa_family_t</span> sin_family;<span class="comment">// 地址族：AF_INET</span></span><br><span class="line"><span class="type">u_int16_t</span> sin_port;<span class="comment">// 端口号，要用网络字节序表示</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr;<span class="comment">// IPv4地址结构体</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">u_int32_t</span> s_addr;<span class="comment">// IPv4地址，网络字节序表示</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* IPv6 */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in6</span></span><br><span class="line">&#123;</span><br><span class="line">    sa_family sin6_family;</span><br><span class="line">    <span class="type">u_int16_t</span> sin6_port;</span><br><span class="line">    <span class="type">u_int32_t</span> sin6_flowinfo;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in6_addr</span> sin6_addr;</span><br><span class="line">    <span class="type">u_int32_t</span> sin6_scope_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in6_addr</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> sa_addr[<span class="number">16</span>];  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​</p><h3 id="IP地址转换函数"><a href="#IP地址转换函数" class="headerlink" title="IP地址转换函数"></a>IP地址转换函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* IP转换函数 点分十进制转换网络字节序*/</span></span><br><span class="line"><span class="comment">// 大端转换函数(点分十进制转网络字节序)</span></span><br><span class="line"><span class="comment">// 小端转换函数(网络字节序转点分十进制)</span></span><br><span class="line"><span class="function"><span class="type">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* strptr)</span></span>;<span class="comment">// 大端转换函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* cp, <span class="keyword">struct</span> in_addr* inp)</span></span>;<span class="comment">// 同上，转换结果存储在inp中</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span></span>;<span class="comment">// 小端转换函数，不可重用，同地址，会覆盖</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 第二组，功能同上 */</span></span><br><span class="line"><span class="comment">// af -- 指定协议族，src -- 需要转换的字符串，dst -- 存储转换结果，大端转换函数，成功返1，失败返0</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span>* src, <span class="type">void</span>* dst)</span></span>;</span><br><span class="line"><span class="comment">// cnt -- 指定目标存储单元大小，通过宏 INET_ADDRSTRLEN(16) INET6_ADDRSTRLEN(46)</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span>* src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> cnt)</span></span>;</span><br></pre></td></tr></table></figure><p>​</p><h2 id="socket系列API"><a href="#socket系列API" class="headerlink" title="socket系列API"></a>socket系列API</h2><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建服务器socket文件描述符 */</span></span><br><span class="line"><span class="comment">// domain -- 指定底层协议族，type -- 指定服务类型(流服务(TCP)、数据报(UDP))，protocol -- 选择传输层对应服务下的具体协议</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain.<span class="type">int</span> type,<span class="type">int</span> protocol)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 命名socket，绑定socket地址 */</span></span><br><span class="line"><span class="comment">// sockfd -- socket文件描述符，my_addr -- sockfd的地址(包括IP、port等)，addlen -- my_addr大小</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* my_addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* listen监听 */</span></span><br><span class="line"><span class="comment">// backlog -- 监听队列最大长度(完全状态的socket连接上限)，在程序中实际监听队列长度会略大，一般为backlog+1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sockfd,<span class="type">int</span> backlog)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* accept接收连接 */</span></span><br><span class="line"><span class="comment">// addr -- sockadd_in类型的结构体，用来存储客户端连接传递过来的客户端地址，addrlen -- addr结构体长度，返回一个新的文件描述符，表示客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr* addr, <span class="type">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* connect发起连接(用于客户端) */</span></span><br><span class="line"><span class="comment">// serv_sock -- 目的服务器地址，成功返回0，失败或超时返回-1，并设置error</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* serv_sock, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 关闭连接(全关) */</span></span><br><span class="line"><span class="comment">// fd -- 客户端/服务器端文件描述符，close并非立即关闭，而是减去引用，比如调用创建进程的函数fork，fd引用被加1，就需要关闭子进程和父进程的文件描述符才可以彻底关闭</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">close</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* shutdown半关闭 */</span></span><br><span class="line"><span class="comment">// sockfd -- 待关闭socket，howto -- 关闭方式</span></span><br><span class="line"><span class="comment">// howto可选参数有：SHUT_RD(关闭读),SHUT_WR(关闭写),SHUT_RDWR(同时关闭读写)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shutdown</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> howto)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* recv/send */</span></span><br><span class="line"><span class="comment">// sockfd -- 对应客户端文件描述符，buf -- 读缓冲区，len -- 读缓冲区长度，flags -- 指定事件(例如紧急事件MSG_OOB)</span></span><br><span class="line"><span class="comment">/* recv返参</span></span><br><span class="line"><span class="comment">阻塞：返回接收到的数据大小</span></span><br><span class="line"><span class="comment">非阻塞：返回-1并且错误码为EAGAIN 或 EWOULDBLOCK则表示当前没有数据可读</span></span><br><span class="line"><span class="comment">返回0表示客户端断开了连接</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="type">int</span> sockfd,<span class="type">void</span> *buf,<span class="type">size_t</span> len,<span class="type">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">// buf -- 读缓冲区，其他参数同上</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">send</span><span class="params">(<span class="type">int</span> sockfd,<span class="type">const</span> <span class="type">void</span> *buf,<span class="type">size_t</span> len,<span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* recvfrom/sendto */</span></span><br><span class="line"><span class="comment">// buf -- 读缓冲区，src_addr -- 接收客户端地址</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recvform</span><span class="params">(<span class="type">int</span> sockfd,<span class="type">void</span> *buf,<span class="type">size_t</span> len,<span class="type">int</span> flags,<span class="keyword">struct</span> sockaddr*src_addr,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">socklen_t</span>* addlen)</span></span>;</span><br><span class="line"><span class="comment">// buf -- 写缓冲区，src_addr -- 指定要传输的客户端地址</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="type">int</span> sockfd,<span class="type">const</span> <span class="type">void</span> *buf,<span class="type">size_t</span> len,<span class="type">int</span> flags,<span class="type">const</span> <span class="keyword">struct</span> sockaddr* src_addr,<span class="type">socklen_t</span>* addlen)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="通用数据读写"><a href="#通用数据读写" class="headerlink" title="通用数据读写"></a>通用数据读写</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recvmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> msghdr* msg, <span class="type">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> msghdr* msg, <span class="type">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">msghdr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *msg_name;<span class="comment">/*socket地址*/</span></span><br><span class="line">    <span class="type">socklen_t</span> msg_namelen;<span class="comment">/*socket地址长度*/</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iovec</span>* msg_iov;<span class="comment">/*分散的内存块，见后文*/</span></span><br><span class="line">    <span class="type">int</span> msg_iovlen;<span class="comment">/*分散内存块数量*/</span></span><br><span class="line">    <span class="type">void</span> * msg_control;<span class="comment">/*指向辅助数据的起始位置*/</span></span><br><span class="line">    <span class="type">socklen_t</span> msg_cotrollen;<span class="comment">/*辅助数据大小*/</span></span><br><span class="line">    <span class="type">int</span> msg_flags;<span class="comment">/*辅助函数中的flags参数，并在调试过程中更新*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="带外数据"><a href="#带外数据" class="headerlink" title="带外数据"></a>带外数据</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断带外数据函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sockatmark</span><span class="params">(<span class="type">int</span> sockfd)</span></span>;# 查看对应客户端是否携带带外数据</span><br></pre></td></tr></table></figure><h3 id="获取地址信息函数"><a href="#获取地址信息函数" class="headerlink" title="获取地址信息函数"></a>获取地址信息函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sockfd -- 对应本端socket地址，获取本端sockfd对应地址</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getsockname</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr* address, <span class="type">socklen_t</span>* address_len)</span></span>;</span><br><span class="line"><span class="comment">// sockfd -- 对应远端socket地址，获取远端sockfd对应地址</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getpeername</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr* address, <span class="type">socklen_t</span>* address_len)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="控制文件描述符属性"><a href="#控制文件描述符属性" class="headerlink" title="控制文件描述符属性"></a>控制文件描述符属性</h3><h4 id="getsockopt-setsockopt"><a href="#getsockopt-setsockopt" class="headerlink" title="getsockopt&#x2F;setsockopt"></a>getsockopt&#x2F;setsockopt</h4><blockquote><p>函数参数信息：</p><p>sockfd – 对应操作的目标socket</p><p>level – 指定操作协议的选项(选择层级)</p><p>option_name – 指定选项名字</p><p>option_value – 被操作选项的值</p><p>option_len – 被操作选项的长度</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取option_name对应选项的属性信息</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> option_name, <span class="type">void</span>* option_value, <span class="type">socklen_t</span>* restrict option_len)</span></span>;</span><br><span class="line"><span class="comment">// 修改option_name对应选项属性信息</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> option_name, <span class="type">const</span> <span class="type">void</span>* option_value, <span class="type">socklen_t</span>* restrict option_len)</span></span>;</span><br></pre></td></tr></table></figure><p>![QQ图片20231025153139](C:\Users\Yan chang guo\Desktop\QQ图片20231025153139.png)</p><p>下面讨论部分重要socket选项</p><h4 id="SO-REUSEADDR"><a href="#SO-REUSEADDR" class="headerlink" title="SO_REUSEADDR"></a>SO_REUSEADDR</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 强制退出TIME_WAIT状态,重用端口</span></span><br><span class="line"><span class="comment">// 实现代码，bind绑定前调用</span></span><br><span class="line"><span class="built_in">setsockopt</span>(sock, SQL_SOCKET, SQL_REUSEADDR, &amp;reuse, <span class="built_in">siezof</span>(reuse));</span><br></pre></td></tr></table></figure><h4 id="SO-RECVBUF和SO-SNDBUF选项"><a href="#SO-RECVBUF和SO-SNDBUF选项" class="headerlink" title="SO_RECVBUF和SO_SNDBUF选项"></a>SO_RECVBUF和SO_SNDBUF选项</h4><blockquote><p>&#x2F;&#x2F; 接收缓冲区,bind前调用<br>SO_RCVBUF<br>&#x2F;&#x2F; 发送缓冲区<br>SO_SNDBUF</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例代码：github地址</span><br></pre></td></tr></table></figure><h4 id="SO-RCVLOWAT和SO-SNDLOWAT"><a href="#SO-RCVLOWAT和SO-SNDLOWAT" class="headerlink" title="SO_RCVLOWAT和SO_SNDLOWAT"></a>SO_RCVLOWAT和SO_SNDLOWAT</h4><blockquote><p>SO_RCVLOWAT和SO_SNDLOWAT选项分别表示TCP接收缓冲区和发送缓冲区的低水位标记。一般被IO复用调用，用于检查select的可读可写，当TCP缓冲区中的数据总数低于低水位标记时，IO通知应用程序可以做对应的读写操作</p></blockquote><h4 id="SO-LINGER"><a href="#SO-LINGER" class="headerlink" title="SO_LINGER"></a>SO_LINGER</h4><blockquote><p>SO_LINGER选项用于控制close系统调用在关闭TCP连接时的行为，设置(获取)SO_LINGER选项的值时，我们需要给setsockopt(getsockopt)系统调用返回一个linger类型的结构体</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">linger</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> l_onoff;<span class="comment">/* 开启(非0)关闭(0) */</span></span><br><span class="line"><span class="type">int</span> l_linger;<span class="comment">/* 滞留时间 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="网络信息API"><a href="#网络信息API" class="headerlink" title="网络信息API"></a>网络信息API</h2><h4 id="getservbyname-getservbyport"><a href="#getservbyname-getservbyport" class="headerlink" title="getservbyname&#x2F;getservbyport"></a>getservbyname&#x2F;getservbyport</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// name -- 指定目标服务的名字， port目标服务对应的端口号， proto参数指定服务类型，</span></span><br><span class="line"><span class="comment">/* getservbyname根据名称过去某个服务的完整信息 */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">servent</span>* <span class="built_in">getservbyname</span>(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">const</span> <span class="type">char</span>* proto);</span><br><span class="line"><span class="comment">/* getservbyport根据端口号获取某个服务的完整信息 */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">servent</span>* <span class="built_in">getservbyport</span>(<span class="type">int</span> port, <span class="type">const</span> <span class="type">char</span>* proto);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* servent结构体指针 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">servnet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* s_namel;<span class="comment">/* 服务名称 */</span></span><br><span class="line">    <span class="type">char</span>** s_aliases;<span class="comment">/* 服务的别名列表，可能有多个 */</span></span><br><span class="line">    <span class="type">int</span> s_port;<span class="comment">/* 端口号 */</span></span><br><span class="line">    <span class="type">char</span>* s_proto;<span class="comment">/* 服务类型，通常是tcp或者udp */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="gethostbyname-gethostbyaddr"><a href="#gethostbyname-gethostbyaddr" class="headerlink" title="gethostbyname&#x2F;gethostbyaddr"></a>gethostbyname&#x2F;gethostbyaddr</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gethostbyname -- 根据主机名来获取主机信息</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hostent</span>* <span class="built_in">gethostbyname</span>(<span class="type">const</span> <span class="type">char</span>* name);</span><br><span class="line"><span class="comment">// gethostbyname -- 根据主机IP来获取主机信息</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hostent</span>* <span class="built_in">gethostbyaddr</span>(<span class="type">const</span> <span class="type">void</span>* addr, <span class="type">size_t</span> len, <span class="type">int</span> type);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hostent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* h_name;<span class="comment">/* 主机名 */</span></span><br><span class="line">    <span class="type">char</span>** h_aliases;<span class="comment">/* 主机别名列表 */</span></span><br><span class="line">    <span class="type">int</span> h_addrtype;<span class="comment">/* 地址类型 */</span></span><br><span class="line">    <span class="type">int</span> h_length;<span class="comment">/* 地址长度 */</span></span><br><span class="line">    <span class="type">char</span>** h_addr_list;<span class="comment">/* 按网络字节序列出的主机IP地址列表 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="getaddrinfo"><a href="#getaddrinfo" class="headerlink" title="getaddrinfo"></a>getaddrinfo</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">函数功能：可通过主机名获得IP地址(重用gethostbyname)，或通过服务名获得端口号(重用getservbyname)</span></span><br><span class="line"><span class="comment">hostname -- 可接受主机名/IP地址 </span></span><br><span class="line"><span class="comment">service -- 可接收服务名</span></span><br><span class="line"><span class="comment">hints -- 应用程序给getaddrinfo的提示，用以对getaddrinfo进行更精确的控制，hints可以被设置为NULL，表示允许返回任何可用的结果</span></span><br><span class="line"><span class="comment">result -- 指向一个链表，用于存储getaddinfo反馈的结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getaddrinfo</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* hostname,<span class="type">const</span> <span class="type">char</span>* service,<span class="type">const</span> <span class="keyword">struct</span> addrinfo* hints, <span class="keyword">struct</span> addrinfo** result)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* addrinfo结构体原型 */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">addrinfo</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ai_flags;<span class="comment">/*  */</span></span><br><span class="line">  <span class="type">int</span> ai_family;<span class="comment">/* 地址族 */</span></span><br><span class="line">  <span class="type">int</span> ai_socktype;<span class="comment">/* 服务类型(SOCK_STREAM/SOCK_DGRAM)</span></span><br><span class="line"><span class="comment">  int ai_protocol;/* 具体的网络协议 */</span></span><br><span class="line">  <span class="type">socklen_t</span> ai_addrlen;<span class="comment">/* socket地址ai_addr的长度  */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sockaddr</span> *ai_addr;<span class="comment">/* 主机的别名  */</span></span><br><span class="line">  <span class="type">char</span> *ai_canonname;<span class="comment">/* 指向socket地址  */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">addrinfo</span> *ai_next;<span class="comment">/* 指向下一个sockinfo结构对象  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><strong>getaddrinfo使用实例：</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">addrinfo</span> hints;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">addrinfo</span>* res;<span class="comment">// res被隐式分配堆内存</span></span><br><span class="line"><span class="built_in">bzero</span>(&amp;hints,<span class="built_in">sizeof</span>(hints));</span><br><span class="line">hints.ai_socktype = SOCK_STREAM;</span><br><span class="line"><span class="built_in">getaddrinfo</span>(<span class="string">&quot;ernest-laptop&quot;</span>, <span class="string">&quot;daytime&quot;</span>, &amp;hints, &amp;res);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 所以还需要调用以下函数来释放内存 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">freeaddrinfo</span><span class="params">(<span class="keyword">struct</span> addrinfo* res)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="freeaddrinfo"><a href="#freeaddrinfo" class="headerlink" title="freeaddrinfo"></a>freeaddrinfo</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 用于给getaddrinfo释放链表内存空间 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">freeaddrinfo</span><span class="params">(<span class="keyword">struct</span> addrinfo* listtable)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="getnameinfo"><a href="#getnameinfo" class="headerlink" title="getnameinfo"></a>getnameinfo</h4><blockquote><p>通过socket地址获得以字符串表示的主机名(底层实现为gethostbyname函数)和服务名(底层实现为getservbtname函数)，根据Linux规范调用可重用版本需要加 “_r”。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 函数原型 */</span></span><br><span class="line"><span class="comment">/* 参数说明 */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">host -- 存储返回的主机名</span></span><br><span class="line"><span class="comment">serv -- 存储返回的服务名</span></span><br><span class="line"><span class="comment">flags -- 控制getnameinfo的行为</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getnameinfo</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sockaddr* sockaddr, <span class="type">socklen_t</span> addrlen, <span class="type">char</span>* host, <span class="type">socklen_t</span> hostlen, <span class="type">char</span>* serv, <span class="type">socket_t</span> servlen, <span class="type">int</span> flags)</span></span>;<span class="comment">// 失败返回error错误码</span></span><br></pre></td></tr></table></figure><h4 id="gai-strerror"><a href="#gai-strerror" class="headerlink" title="gai_strerror"></a>gai_strerror</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 错误码转换字符串函数 */</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">gai_strerror</span><span class="params">(<span class="type">int</span> error)</span></span>;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      
      <comments>http://ycg0508.com/2023/10/27/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
